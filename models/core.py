import numpy as np
import matplotlib.pyplot as plt

from scipy.special import gamma
from dataclasses import dataclass
from typing import Optional, Union, Dict, Any

from models.abc_class import SeismicBasedBedloadTransportModel

@dataclass
class SedimentParams:
    """ Physical parameters for sediment transport modeling.
    """
    rho_s: float = 2700     # sediment density (kg/m3)
    rho_f: float = 1000     # fluid density (kg/m3)
    g: float = 9.81         # gravitational acceleration due to gravity (m/s2)
    CSF: float = 0.8        # Corey shape factor for calculating drag coefficient
    P: float = 3.5          # particle roundness for calculating drag coefficient
    nu: float = 1e-6        # Kinematic viscosity
    C1: float = 2/3         # Rise and fall time for particle ejection

@dataclass
class SeismicParams:
    """ Seismic parameters for estimating group and phase velocities, as well as
    seismic wave attenuation (From Tsai et al., 2012)"""
    v0: float = 2206    # Reference velocity (m/s) at z0 = 1000m
    z0: float = 1000    # Reference depth (m)
    f0: float = 1       # Reference frequency (Hz)
    a: float = 0.272
    Q0: float = 20
    eta: float = 0

    @property
    def zeta(self) -> float:
        return self.a / (1 - self.a)
    
    @property
    def vc0(self) -> float:
        return (self.v0 * gamma(1 + self.a) / (2 * np.pi * self.z0 * self.f0)**self.a)**(1 / (1 - self.a))



class SaltationModel(SeismicBasedBedloadTransportModel):
    """
    The saltation-mode model calculates PSD generated by bedload transport (Tsai et al., 2012), assuming
    all fluvial bedload particle impact vertically and elastically onto the riverbed.
    """
    def __init__(self, sediment_params: Optional[SedimentParams] = None,
                 seismic_params: Optional[SeismicParams] = None,
                 ):
        self.sediment_params = sediment_params if sediment_params else SedimentParams()
        self.seismic_params = seismic_params if seismic_params else SeismicParams()
    
    def estimate_critical_shear(self, theta, method: str ='gimbert'):
        # Estimate the critical shear stress using Gimbert et al. (2019) or Lamb et al. (2008) based on
        # slope of the basin
        if method == 'gimbert':
            dummy = 0.407 * np.log(142 * theta)
            return np.exp(2.59e-2 * (dummy**4) + 8.94e-2 * (dummy**3) + 
                         0.142 * (dummy**2) + 0.41 * dummy - 3.14)
        elif method == 'lamb':
            return 0.15 * (theta)**0.25
        else:
            raise ValueError(f"Unknown method: {method}")
        
    def estimate_drag_coeff(self, D: float) -> float:
        R = (self.sediment_params.rho_s - self.sediment_params.rho_f) / self.sediment_params.rho_f
        
        D_star = (R * self.sediment_params.g * D**3) / self.sediment_params.nu**2
        D_star = np.log10(D_star)
        
        R1 = (-3.76715 + 1.92944 * D_star - 0.09815 * (D_star**2) - 
              0.00575 * (D_star**3) + 0.00056 * (D_star**4))
        
        R2 = (np.log10(1 - ((1 - self.sediment_params.CSF) / 0.85)) - 
              (1 - self.sediment_params.CSF)**2.3 * np.tanh(D_star - 4.6) + 
              0.3 * (0.5 - self.sediment_params.CSF) * (1 - self.sediment_params.CSF)**2 * 
              (D_star - 4.6))
        
        R3 = (0.65 - ((self.sediment_params.CSF / 2.83) * np.tanh(D_star - 4.6)))**(
            1 + ((3.5 - self.sediment_params.P) / 2.5))
        
        W_star = R3 * 10**(R1 + R2)
        w_s = (W_star * R * self.sediment_params.g * self.sediment_params.nu)**(1/3)
        cD = (4 / 3) * (R * self.sediment_params.g * D) / (w_s**2)
        
        return cD
    
    def calculate_bedload_parameters(self, D: float, H: float, theta: float, 
                                   tau_c: float) -> tuple[float, float, float]:
        """Calculate bedload transport parameters."""
        R = (self.sediment_params.rho_s - self.sediment_params.rho_f) / self.sediment_params.rho_f
        u = np.sqrt(self.sediment_params.g * H * theta)
        tau = u**2 / R / self.sediment_params.g / D
        
        # if tau / tau_c <= 1:
        #     raise ValueError("tau/tau_c <= 1: No bedload transport")
        
        ks = 3 * D  # roughness scale
        U = 8.1 * u * (H / ks)**1.6
        
        Ub = 1.56 * np.sqrt(R * self.sediment_params.g * D) * (tau / tau_c - 1)**0.56
        Hb = 1.44 * D * (tau / tau_c - 1)**0.50
        
        return tau, Ub, Hb
    
    def calculate_seismic_properties(self, f: np.ndarray, r0: float) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
        """Calculate seismic wave properties and attenuation."""
        vc = self.seismic_params.vc0 * (f / self.seismic_params.f0)**(-self.seismic_params.zeta)
        vu = vc / (1 + self.seismic_params.zeta)
        
        beta = (2 * np.pi * r0 * (1 + self.seismic_params.zeta) * 
                f**(1 + self.seismic_params.zeta - self.seismic_params.eta) / 
                (self.seismic_params.vc0 * self.seismic_params.Q0 * 
                 self.seismic_params.f0**(self.seismic_params.zeta - self.seismic_params.eta)))
        
        chi = (2 * np.log(1 + 1/beta) * np.exp(-2 * beta) + 
               (1 - np.exp(-beta)) * np.exp(-beta) * np.sqrt(2 * np.pi / beta))
        
        return vc, vu, chi

    def forward_psd(self, f: np.ndarray, 
                    D: Union[float, np.ndarray], 
                    H: Union[float, np.ndarray], 
                    W: float, 
                    theta: float, 
                    r0: float,
                    qb: float,
                    D50: Union[float, np.ndarray] = None,
                    tau_c50: float = None) -> np.ndarray:
        """
        Calculate the power spectral density (PSD) for sediment transport in saltation.
        """
        f = np.asarray(f)
        if D50 is None:
            D50 = D
        
        # Calculate critical shear stress for D50
        if tau_c50 is None:
            tau_c50 = self.estimate_critical_shear(theta)
            print(tau_c50)
        
        tau_c = tau_c50 * (D / D50)**(-0.9)
        print(tau_c)
        if tau_c.any() < 0.03:
            tau_c = 0.03
        if tau_c.any() > 0.06:
            tau_c = 0.06
        
        # Calculate bedload parameters
        _, Ub, Hb = self.calculate_bedload_parameters(D, H, theta, tau_c)
            
        # Calculate drag coefficient
        cD = self.estimate_drag_coeff(D)
            
        # Calculate seismic properties
        vc, vu, chi = self.calculate_seismic_properties(f, r0)
            
        # Particle properties
        Vp = np.pi * D**3 / 6
        m = self.sediment_params.rho_s * Vp
            
        # Terminal settling velocity and impact velocity
        wst = np.sqrt(4 * (self.sediment_params.rho_s - self.sediment_params.rho_f) / 
                         self.sediment_params.rho_f * self.sediment_params.g * D / 3 / cD)
            
        Hb_c = (3 * cD * self.sediment_params.rho_f * Hb / 
                   (2 * self.sediment_params.rho_s * D * np.cos(np.arctan(theta))))
            
        wi = (wst * np.cos(np.arctan(theta)) * 
                 np.sqrt(1 - np.exp(-Hb_c)))
            
        # Average settling velocity
        ws = (Hb_c * wst * np.cos(np.arctan(theta)) / 
                 (2 * np.log(np.exp(Hb_c/2) + np.sqrt(np.exp(Hb_c) - 1))))
            
        # Impact rate
        rate = self.sediment_params.C1 * W * qb * ws / (Vp * Ub * Hb)
        print(rate)
        # Final PSD calculation
        PSD = (rate * (np.pi**2 * m**2 * wi**2) / self.sediment_params.rho_s**2 * 
                  f**3 / vc**3 / vu**2 * chi)
            
        return PSD

    def inverse_bedload(self, PSD, f, D, H, W, theta, r0, qb,**kwargs):
        """
        Inverse calculation for bedload transport based on seismic data in saltation.
        """
        qb = 1
        PSD_star = self.forward_psd(f, D, H, W, theta, r0, qb, **kwargs)
        PSD_median = np.median(PSD_star)

        
        

class MultimodeModel(SeismicBasedBedloadTransportModel):
    """
    Multimode model (from Luong et al., 2024)
    """

    def forward_psd(self, frequency, grain_size, flow_depth, channel_width, slope_angle, source_receiver_distance, qb, **kwargs):
    
        pass

    def inverse_bedload(self, frequency, grain_size, flow_depth, channel_width, slope_angle, source_receiver_distance, qb, **kwargs):

        pass